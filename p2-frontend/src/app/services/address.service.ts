import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Injectable } from '@angular/core';
import { catchError, Observable, throwError, retry } from 'rxjs';
import { User } from './user.service';

@Injectable({
  providedIn: 'root'
})
export class AddressService {

  //base url to concatenate with in this script. will be replaced with database link in P3.
  baseUrl: string = "http://localhost:8080"
  addressUri: string = "/address"
  static httpOptions: object;

  constructor(private http: HttpClient) { }

  //reference for use later
  httpOptions = {
    headers: new HttpHeaders({
      'Content-Type': 'application/json'
    })
  }

  //this.http.get raw link deserted 
  //data = " --data-raw '{\"addressId\":1}"

  errorHandler(e: any): any {
    console.log("Error handler invoked...");
    let errorMessage = '';
    if (e.error instanceof ErrorEvent) {
      // Get client-side error. who's the client?
      errorMessage = e.error.message;
    } else {
      // Get server-side error
      errorMessage = `Error Code: ${e.status}\nMessage: ${e.message}`;
    }
    console.log(errorMessage);
    return throwError(() => new Error(errorMessage));
  }


  //POST
  postNewAddress(uri: string, body: object, options: object): Observable<any> {
    console.log("POST: ", this.baseUrl + uri, body, options);
    //this is the request that send to backend with the url same as on postman to post info to the backend.
    return this.http.post<any>(this.baseUrl + uri, JSON.stringify(body), this.httpOptions)
      .pipe(
        retry(3),
        catchError(this.errorHandler)
      )
  }

  //GET
  getAddressById(uri: string, body: object, options: object): Observable<any> {
    console.log("GET: ", this.baseUrl + uri + body, options);
    //this return request is what gets sent to back end with the url same as on postman to get info from the backend.
    return this.http.post<any>(this.baseUrl + uri, JSON.stringify(body), this.httpOptions)
      .pipe(
        retry(1),
        catchError(this.errorHandler)
      )
  }

  getAddressByUser(body: object): Observable<any> {
    console.log("Getting addresses by User...");
    return this.http.post<object>(this.baseUrl + "/address/user", body, { headers: new HttpHeaders({ 'Content-Type': 'application/json' }) })
      .pipe(
        retry(1),
        catchError(this.errorHandler)
      )
  }

  //PUT
  updateAddress(uri: string, body: object, options: object): Observable<any> {
    console.log("PUT: ", this.baseUrl + uri, body, options);
    //this return request is what gets sent to back end with the url same as on postman to update info to the backend.
    return this.http.put<any>(this.baseUrl + "/address/update", JSON.stringify(body), this.httpOptions)
      .pipe(
        retry(1),
        catchError(this.errorHandler)
      )
  }

  //DELETE
  deleteAddress(uri: string, body: object, options: object): Observable<any> {
    console.log("DELETE: ", this.baseUrl + uri, body, options);
    //this return request is what gets sent to back end with the url same as on postman to update info to the backend.
    return this.http.delete<any>(this.baseUrl + uri + JSON.stringify(body), this.httpOptions)
      .pipe(
        retry(1),
        catchError(this.errorHandler)
      )
  }

}


//address object to cancatenate in json body later
export class Address {
  addressId: number;
  number: string = "";
  street: string = "";
  city: string = "";
  state: string = "";
  zipCode: string = "";
  userId: any;

  constructor(_number: string, _street: string, _city: string, _state: string, _zipCode: string, _userId: any) {
    //id needs to be the address id same as the last address the user input. 
    //I need a variable that keeps track of the last id that's generated by user.
    this.addressId = 0;
    this.number = _number;
    this.street = _street;
    this.city = _city;
    this.state = _state;
    this.zipCode = _zipCode;
    this.userId = _userId;
  }
}

export class CurrentAddress {
  addressId: number;
  number: string = "";
  street: string = "";
  city: string = "";
  state: string = "";
  zipCode: string = "";
  userId: any;


  constructor(_addressId: number) {
    this.addressId = _addressId;

  }
}

export class AllAddress {
  constructor() { }
  items: Address[] = [];

  addToAllAddress(address: Address) {
    this.items.push(address);
  }

  getAddress() {
    return this.items;
  }

  deleteAllAddress() {
    this.items = [];
    return this.items;
  }
}